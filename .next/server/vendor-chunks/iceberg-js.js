"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/iceberg-js";
exports.ids = ["vendor-chunks/iceberg-js"];
exports.modules = {

/***/ "(rsc)/./node_modules/iceberg-js/dist/index.mjs":
/*!************************************************!*\
  !*** ./node_modules/iceberg-js/dist/index.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IcebergError: () => (/* binding */ IcebergError),\n/* harmony export */   IcebergRestCatalog: () => (/* binding */ IcebergRestCatalog),\n/* harmony export */   getCurrentSchema: () => (/* binding */ getCurrentSchema),\n/* harmony export */   isDecimalType: () => (/* binding */ isDecimalType),\n/* harmony export */   isFixedType: () => (/* binding */ isFixedType),\n/* harmony export */   parseDecimalType: () => (/* binding */ parseDecimalType),\n/* harmony export */   parseFixedType: () => (/* binding */ parseFixedType),\n/* harmony export */   typesEqual: () => (/* binding */ typesEqual)\n/* harmony export */ });\n// src/errors/IcebergError.ts\r\nvar IcebergError = class extends Error {\r\n  constructor(message, opts) {\r\n    super(message);\r\n    this.name = \"IcebergError\";\r\n    this.status = opts.status;\r\n    this.icebergType = opts.icebergType;\r\n    this.icebergCode = opts.icebergCode;\r\n    this.details = opts.details;\r\n    this.isCommitStateUnknown = opts.icebergType === \"CommitStateUnknownException\" || [500, 502, 504].includes(opts.status) && opts.icebergType?.includes(\"CommitState\") === true;\r\n  }\r\n  /**\r\n   * Returns true if the error is a 404 Not Found error.\r\n   */\r\n  isNotFound() {\r\n    return this.status === 404;\r\n  }\r\n  /**\r\n   * Returns true if the error is a 409 Conflict error.\r\n   */\r\n  isConflict() {\r\n    return this.status === 409;\r\n  }\r\n  /**\r\n   * Returns true if the error is a 419 Authentication Timeout error.\r\n   */\r\n  isAuthenticationTimeout() {\r\n    return this.status === 419;\r\n  }\r\n};\r\n\r\n// src/utils/url.ts\r\nfunction buildUrl(baseUrl, path, query) {\r\n  const url = new URL(path, baseUrl);\r\n  if (query) {\r\n    for (const [key, value] of Object.entries(query)) {\r\n      if (value !== void 0) {\r\n        url.searchParams.set(key, value);\r\n      }\r\n    }\r\n  }\r\n  return url.toString();\r\n}\r\n\r\n// src/http/createFetchClient.ts\r\nasync function buildAuthHeaders(auth) {\r\n  if (!auth || auth.type === \"none\") {\r\n    return {};\r\n  }\r\n  if (auth.type === \"bearer\") {\r\n    return { Authorization: `Bearer ${auth.token}` };\r\n  }\r\n  if (auth.type === \"header\") {\r\n    return { [auth.name]: auth.value };\r\n  }\r\n  if (auth.type === \"custom\") {\r\n    return await auth.getHeaders();\r\n  }\r\n  return {};\r\n}\r\nfunction createFetchClient(options) {\r\n  const fetchFn = options.fetchImpl ?? globalThis.fetch;\r\n  return {\r\n    async request({\r\n      method,\r\n      path,\r\n      query,\r\n      body,\r\n      headers\r\n    }) {\r\n      const url = buildUrl(options.baseUrl, path, query);\r\n      const authHeaders = await buildAuthHeaders(options.auth);\r\n      const res = await fetchFn(url, {\r\n        method,\r\n        headers: {\r\n          ...body ? { \"Content-Type\": \"application/json\" } : {},\r\n          ...authHeaders,\r\n          ...headers\r\n        },\r\n        body: body ? JSON.stringify(body) : void 0\r\n      });\r\n      const text = await res.text();\r\n      const isJson = (res.headers.get(\"content-type\") || \"\").includes(\"application/json\");\r\n      const data = isJson && text ? JSON.parse(text) : text;\r\n      if (!res.ok) {\r\n        const errBody = isJson ? data : void 0;\r\n        const errorDetail = errBody?.error;\r\n        throw new IcebergError(\r\n          errorDetail?.message ?? `Request failed with status ${res.status}`,\r\n          {\r\n            status: res.status,\r\n            icebergType: errorDetail?.type,\r\n            icebergCode: errorDetail?.code,\r\n            details: errBody\r\n          }\r\n        );\r\n      }\r\n      return { status: res.status, headers: res.headers, data };\r\n    }\r\n  };\r\n}\r\n\r\n// src/catalog/namespaces.ts\r\nfunction namespaceToPath(namespace) {\r\n  return namespace.join(\"\u001f\");\r\n}\r\nvar NamespaceOperations = class {\r\n  constructor(client, prefix = \"\") {\r\n    this.client = client;\r\n    this.prefix = prefix;\r\n  }\r\n  async listNamespaces(parent) {\r\n    const query = parent ? { parent: namespaceToPath(parent.namespace) } : void 0;\r\n    const response = await this.client.request({\r\n      method: \"GET\",\r\n      path: `${this.prefix}/namespaces`,\r\n      query\r\n    });\r\n    return response.data.namespaces.map((ns) => ({ namespace: ns }));\r\n  }\r\n  async createNamespace(id, metadata) {\r\n    const request = {\r\n      namespace: id.namespace,\r\n      properties: metadata?.properties\r\n    };\r\n    const response = await this.client.request({\r\n      method: \"POST\",\r\n      path: `${this.prefix}/namespaces`,\r\n      body: request\r\n    });\r\n    return response.data;\r\n  }\r\n  async dropNamespace(id) {\r\n    await this.client.request({\r\n      method: \"DELETE\",\r\n      path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`\r\n    });\r\n  }\r\n  async loadNamespaceMetadata(id) {\r\n    const response = await this.client.request({\r\n      method: \"GET\",\r\n      path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`\r\n    });\r\n    return {\r\n      properties: response.data.properties\r\n    };\r\n  }\r\n  async namespaceExists(id) {\r\n    try {\r\n      await this.client.request({\r\n        method: \"HEAD\",\r\n        path: `${this.prefix}/namespaces/${namespaceToPath(id.namespace)}`\r\n      });\r\n      return true;\r\n    } catch (error) {\r\n      if (error instanceof IcebergError && error.status === 404) {\r\n        return false;\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n  async createNamespaceIfNotExists(id, metadata) {\r\n    try {\r\n      return await this.createNamespace(id, metadata);\r\n    } catch (error) {\r\n      if (error instanceof IcebergError && error.status === 409) {\r\n        return;\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n};\r\n\r\n// src/catalog/tables.ts\r\nfunction namespaceToPath2(namespace) {\r\n  return namespace.join(\"\u001f\");\r\n}\r\nvar TableOperations = class {\r\n  constructor(client, prefix = \"\", accessDelegation) {\r\n    this.client = client;\r\n    this.prefix = prefix;\r\n    this.accessDelegation = accessDelegation;\r\n  }\r\n  async listTables(namespace) {\r\n    const response = await this.client.request({\r\n      method: \"GET\",\r\n      path: `${this.prefix}/namespaces/${namespaceToPath2(namespace.namespace)}/tables`\r\n    });\r\n    return response.data.identifiers;\r\n  }\r\n  async createTable(namespace, request) {\r\n    const headers = {};\r\n    if (this.accessDelegation) {\r\n      headers[\"X-Iceberg-Access-Delegation\"] = this.accessDelegation;\r\n    }\r\n    const response = await this.client.request({\r\n      method: \"POST\",\r\n      path: `${this.prefix}/namespaces/${namespaceToPath2(namespace.namespace)}/tables`,\r\n      body: request,\r\n      headers\r\n    });\r\n    return response.data.metadata;\r\n  }\r\n  async updateTable(id, request) {\r\n    const response = await this.client.request({\r\n      method: \"POST\",\r\n      path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\r\n      body: request\r\n    });\r\n    return {\r\n      \"metadata-location\": response.data[\"metadata-location\"],\r\n      metadata: response.data.metadata\r\n    };\r\n  }\r\n  async dropTable(id, options) {\r\n    await this.client.request({\r\n      method: \"DELETE\",\r\n      path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\r\n      query: { purgeRequested: String(options?.purge ?? false) }\r\n    });\r\n  }\r\n  async loadTable(id) {\r\n    const headers = {};\r\n    if (this.accessDelegation) {\r\n      headers[\"X-Iceberg-Access-Delegation\"] = this.accessDelegation;\r\n    }\r\n    const response = await this.client.request({\r\n      method: \"GET\",\r\n      path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\r\n      headers\r\n    });\r\n    return response.data.metadata;\r\n  }\r\n  async tableExists(id) {\r\n    const headers = {};\r\n    if (this.accessDelegation) {\r\n      headers[\"X-Iceberg-Access-Delegation\"] = this.accessDelegation;\r\n    }\r\n    try {\r\n      await this.client.request({\r\n        method: \"HEAD\",\r\n        path: `${this.prefix}/namespaces/${namespaceToPath2(id.namespace)}/tables/${id.name}`,\r\n        headers\r\n      });\r\n      return true;\r\n    } catch (error) {\r\n      if (error instanceof IcebergError && error.status === 404) {\r\n        return false;\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n  async createTableIfNotExists(namespace, request) {\r\n    try {\r\n      return await this.createTable(namespace, request);\r\n    } catch (error) {\r\n      if (error instanceof IcebergError && error.status === 409) {\r\n        return await this.loadTable({ namespace: namespace.namespace, name: request.name });\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n};\r\n\r\n// src/catalog/IcebergRestCatalog.ts\r\nvar IcebergRestCatalog = class {\r\n  /**\r\n   * Creates a new Iceberg REST Catalog client.\r\n   *\r\n   * @param options - Configuration options for the catalog client\r\n   */\r\n  constructor(options) {\r\n    let prefix = \"v1\";\r\n    if (options.catalogName) {\r\n      prefix += `/${options.catalogName}`;\r\n    }\r\n    const baseUrl = options.baseUrl.endsWith(\"/\") ? options.baseUrl : `${options.baseUrl}/`;\r\n    this.client = createFetchClient({\r\n      baseUrl,\r\n      auth: options.auth,\r\n      fetchImpl: options.fetch\r\n    });\r\n    this.accessDelegation = options.accessDelegation?.join(\",\");\r\n    this.namespaceOps = new NamespaceOperations(this.client, prefix);\r\n    this.tableOps = new TableOperations(this.client, prefix, this.accessDelegation);\r\n  }\r\n  /**\r\n   * Lists all namespaces in the catalog.\r\n   *\r\n   * @param parent - Optional parent namespace to list children under\r\n   * @returns Array of namespace identifiers\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // List all top-level namespaces\r\n   * const namespaces = await catalog.listNamespaces();\r\n   *\r\n   * // List namespaces under a parent\r\n   * const children = await catalog.listNamespaces({ namespace: ['analytics'] });\r\n   * ```\r\n   */\r\n  async listNamespaces(parent) {\r\n    return this.namespaceOps.listNamespaces(parent);\r\n  }\r\n  /**\r\n   * Creates a new namespace in the catalog.\r\n   *\r\n   * @param id - Namespace identifier to create\r\n   * @param metadata - Optional metadata properties for the namespace\r\n   * @returns Response containing the created namespace and its properties\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const response = await catalog.createNamespace(\r\n   *   { namespace: ['analytics'] },\r\n   *   { properties: { owner: 'data-team' } }\r\n   * );\r\n   * console.log(response.namespace); // ['analytics']\r\n   * console.log(response.properties); // { owner: 'data-team', ... }\r\n   * ```\r\n   */\r\n  async createNamespace(id, metadata) {\r\n    return this.namespaceOps.createNamespace(id, metadata);\r\n  }\r\n  /**\r\n   * Drops a namespace from the catalog.\r\n   *\r\n   * The namespace must be empty (contain no tables) before it can be dropped.\r\n   *\r\n   * @param id - Namespace identifier to drop\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * await catalog.dropNamespace({ namespace: ['analytics'] });\r\n   * ```\r\n   */\r\n  async dropNamespace(id) {\r\n    await this.namespaceOps.dropNamespace(id);\r\n  }\r\n  /**\r\n   * Loads metadata for a namespace.\r\n   *\r\n   * @param id - Namespace identifier to load\r\n   * @returns Namespace metadata including properties\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const metadata = await catalog.loadNamespaceMetadata({ namespace: ['analytics'] });\r\n   * console.log(metadata.properties);\r\n   * ```\r\n   */\r\n  async loadNamespaceMetadata(id) {\r\n    return this.namespaceOps.loadNamespaceMetadata(id);\r\n  }\r\n  /**\r\n   * Lists all tables in a namespace.\r\n   *\r\n   * @param namespace - Namespace identifier to list tables from\r\n   * @returns Array of table identifiers\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const tables = await catalog.listTables({ namespace: ['analytics'] });\r\n   * console.log(tables); // [{ namespace: ['analytics'], name: 'events' }, ...]\r\n   * ```\r\n   */\r\n  async listTables(namespace) {\r\n    return this.tableOps.listTables(namespace);\r\n  }\r\n  /**\r\n   * Creates a new table in the catalog.\r\n   *\r\n   * @param namespace - Namespace to create the table in\r\n   * @param request - Table creation request including name, schema, partition spec, etc.\r\n   * @returns Table metadata for the created table\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const metadata = await catalog.createTable(\r\n   *   { namespace: ['analytics'] },\r\n   *   {\r\n   *     name: 'events',\r\n   *     schema: {\r\n   *       type: 'struct',\r\n   *       fields: [\r\n   *         { id: 1, name: 'id', type: 'long', required: true },\r\n   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }\r\n   *       ],\r\n   *       'schema-id': 0\r\n   *     },\r\n   *     'partition-spec': {\r\n   *       'spec-id': 0,\r\n   *       fields: [\r\n   *         { source_id: 2, field_id: 1000, name: 'ts_day', transform: 'day' }\r\n   *       ]\r\n   *     }\r\n   *   }\r\n   * );\r\n   * ```\r\n   */\r\n  async createTable(namespace, request) {\r\n    return this.tableOps.createTable(namespace, request);\r\n  }\r\n  /**\r\n   * Updates an existing table's metadata.\r\n   *\r\n   * Can update the schema, partition spec, or properties of a table.\r\n   *\r\n   * @param id - Table identifier to update\r\n   * @param request - Update request with fields to modify\r\n   * @returns Response containing the metadata location and updated table metadata\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const response = await catalog.updateTable(\r\n   *   { namespace: ['analytics'], name: 'events' },\r\n   *   {\r\n   *     properties: { 'read.split.target-size': '134217728' }\r\n   *   }\r\n   * );\r\n   * console.log(response['metadata-location']); // s3://...\r\n   * console.log(response.metadata); // TableMetadata object\r\n   * ```\r\n   */\r\n  async updateTable(id, request) {\r\n    return this.tableOps.updateTable(id, request);\r\n  }\r\n  /**\r\n   * Drops a table from the catalog.\r\n   *\r\n   * @param id - Table identifier to drop\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * await catalog.dropTable({ namespace: ['analytics'], name: 'events' });\r\n   * ```\r\n   */\r\n  async dropTable(id, options) {\r\n    await this.tableOps.dropTable(id, options);\r\n  }\r\n  /**\r\n   * Loads metadata for a table.\r\n   *\r\n   * @param id - Table identifier to load\r\n   * @returns Table metadata including schema, partition spec, location, etc.\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const metadata = await catalog.loadTable({ namespace: ['analytics'], name: 'events' });\r\n   * console.log(metadata.schema);\r\n   * console.log(metadata.location);\r\n   * ```\r\n   */\r\n  async loadTable(id) {\r\n    return this.tableOps.loadTable(id);\r\n  }\r\n  /**\r\n   * Checks if a namespace exists in the catalog.\r\n   *\r\n   * @param id - Namespace identifier to check\r\n   * @returns True if the namespace exists, false otherwise\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const exists = await catalog.namespaceExists({ namespace: ['analytics'] });\r\n   * console.log(exists); // true or false\r\n   * ```\r\n   */\r\n  async namespaceExists(id) {\r\n    return this.namespaceOps.namespaceExists(id);\r\n  }\r\n  /**\r\n   * Checks if a table exists in the catalog.\r\n   *\r\n   * @param id - Table identifier to check\r\n   * @returns True if the table exists, false otherwise\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const exists = await catalog.tableExists({ namespace: ['analytics'], name: 'events' });\r\n   * console.log(exists); // true or false\r\n   * ```\r\n   */\r\n  async tableExists(id) {\r\n    return this.tableOps.tableExists(id);\r\n  }\r\n  /**\r\n   * Creates a namespace if it does not exist.\r\n   *\r\n   * If the namespace already exists, returns void. If created, returns the response.\r\n   *\r\n   * @param id - Namespace identifier to create\r\n   * @param metadata - Optional metadata properties for the namespace\r\n   * @returns Response containing the created namespace and its properties, or void if it already exists\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const response = await catalog.createNamespaceIfNotExists(\r\n   *   { namespace: ['analytics'] },\r\n   *   { properties: { owner: 'data-team' } }\r\n   * );\r\n   * if (response) {\r\n   *   console.log('Created:', response.namespace);\r\n   * } else {\r\n   *   console.log('Already exists');\r\n   * }\r\n   * ```\r\n   */\r\n  async createNamespaceIfNotExists(id, metadata) {\r\n    return this.namespaceOps.createNamespaceIfNotExists(id, metadata);\r\n  }\r\n  /**\r\n   * Creates a table if it does not exist.\r\n   *\r\n   * If the table already exists, returns its metadata instead.\r\n   *\r\n   * @param namespace - Namespace to create the table in\r\n   * @param request - Table creation request including name, schema, partition spec, etc.\r\n   * @returns Table metadata for the created or existing table\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const metadata = await catalog.createTableIfNotExists(\r\n   *   { namespace: ['analytics'] },\r\n   *   {\r\n   *     name: 'events',\r\n   *     schema: {\r\n   *       type: 'struct',\r\n   *       fields: [\r\n   *         { id: 1, name: 'id', type: 'long', required: true },\r\n   *         { id: 2, name: 'timestamp', type: 'timestamp', required: true }\r\n   *       ],\r\n   *       'schema-id': 0\r\n   *     }\r\n   *   }\r\n   * );\r\n   * ```\r\n   */\r\n  async createTableIfNotExists(namespace, request) {\r\n    return this.tableOps.createTableIfNotExists(namespace, request);\r\n  }\r\n};\r\n\r\n// src/catalog/types.ts\r\nvar DECIMAL_REGEX = /^decimal\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)$/;\r\nvar FIXED_REGEX = /^fixed\\s*\\[\\s*(\\d+)\\s*\\]$/;\r\nfunction parseDecimalType(type) {\r\n  const match = type.match(DECIMAL_REGEX);\r\n  if (!match) return null;\r\n  return {\r\n    precision: parseInt(match[1], 10),\r\n    scale: parseInt(match[2], 10)\r\n  };\r\n}\r\nfunction parseFixedType(type) {\r\n  const match = type.match(FIXED_REGEX);\r\n  if (!match) return null;\r\n  return {\r\n    length: parseInt(match[1], 10)\r\n  };\r\n}\r\nfunction isDecimalType(type) {\r\n  return DECIMAL_REGEX.test(type);\r\n}\r\nfunction isFixedType(type) {\r\n  return FIXED_REGEX.test(type);\r\n}\r\nfunction typesEqual(a, b) {\r\n  const decimalA = parseDecimalType(a);\r\n  const decimalB = parseDecimalType(b);\r\n  if (decimalA && decimalB) {\r\n    return decimalA.precision === decimalB.precision && decimalA.scale === decimalB.scale;\r\n  }\r\n  const fixedA = parseFixedType(a);\r\n  const fixedB = parseFixedType(b);\r\n  if (fixedA && fixedB) {\r\n    return fixedA.length === fixedB.length;\r\n  }\r\n  return a === b;\r\n}\r\nfunction getCurrentSchema(metadata) {\r\n  return metadata.schemas.find((s) => s[\"schema-id\"] === metadata[\"current-schema-id\"]);\r\n}\r\n\r\n\r\n//# sourceMappingURL=index.mjs.map\r\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaWNlYmVyZy1qcy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlCQUF5QixXQUFXO0FBQ2pEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUNBQXFDLElBQUk7QUFDL0Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxXQUFXO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0Q0FBNEM7QUFDekU7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBLEtBQUs7QUFDTCxtREFBbUQsZUFBZTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVksY0FBYyw4QkFBOEI7QUFDdkUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZLGNBQWMsOEJBQThCO0FBQ3ZFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVksY0FBYyw4QkFBOEI7QUFDekUsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVksY0FBYyxzQ0FBc0M7QUFDL0UsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWSxjQUFjLHNDQUFzQztBQUMvRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVksY0FBYywrQkFBK0IsVUFBVSxRQUFRO0FBQzFGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVksY0FBYywrQkFBK0IsVUFBVSxRQUFRO0FBQzFGLGVBQWU7QUFDZixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWSxjQUFjLCtCQUErQixVQUFVLFFBQVE7QUFDMUY7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWSxjQUFjLCtCQUErQixVQUFVLFFBQVE7QUFDNUY7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esc0NBQXNDLG9EQUFvRDtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQSx5RUFBeUUsZ0JBQWdCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELDBCQUEwQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDBCQUEwQjtBQUNuQyxTQUFTLGNBQWM7QUFDdkI7QUFDQSxzQ0FBc0M7QUFDdEMsdUNBQXVDLEtBQUs7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwQkFBMEI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsMEJBQTBCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsMEJBQTBCO0FBQ3pFLDBCQUEwQixNQUFNLDBDQUEwQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDBCQUEwQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBaUQ7QUFDaEUsZUFBZTtBQUNmO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMENBQTBDO0FBQ25EO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwwQ0FBMEM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsMENBQTBDO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCwwQkFBMEI7QUFDOUUsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDBDQUEwQztBQUMxRiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMEJBQTBCO0FBQ25DLFNBQVMsY0FBYztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDBCQUEwQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBaUQ7QUFDaEUsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDd0k7QUFDeEk7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWwtZXN0YXRlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2ljZWJlcmctanMvZGlzdC9pbmRleC5tanM/NGVhZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvZXJyb3JzL0ljZWJlcmdFcnJvci50c1xyXG52YXIgSWNlYmVyZ0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XHJcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgb3B0cykge1xyXG4gICAgc3VwZXIobWVzc2FnZSk7XHJcbiAgICB0aGlzLm5hbWUgPSBcIkljZWJlcmdFcnJvclwiO1xyXG4gICAgdGhpcy5zdGF0dXMgPSBvcHRzLnN0YXR1cztcclxuICAgIHRoaXMuaWNlYmVyZ1R5cGUgPSBvcHRzLmljZWJlcmdUeXBlO1xyXG4gICAgdGhpcy5pY2ViZXJnQ29kZSA9IG9wdHMuaWNlYmVyZ0NvZGU7XHJcbiAgICB0aGlzLmRldGFpbHMgPSBvcHRzLmRldGFpbHM7XHJcbiAgICB0aGlzLmlzQ29tbWl0U3RhdGVVbmtub3duID0gb3B0cy5pY2ViZXJnVHlwZSA9PT0gXCJDb21taXRTdGF0ZVVua25vd25FeGNlcHRpb25cIiB8fCBbNTAwLCA1MDIsIDUwNF0uaW5jbHVkZXMob3B0cy5zdGF0dXMpICYmIG9wdHMuaWNlYmVyZ1R5cGU/LmluY2x1ZGVzKFwiQ29tbWl0U3RhdGVcIikgPT09IHRydWU7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZXJyb3IgaXMgYSA0MDQgTm90IEZvdW5kIGVycm9yLlxyXG4gICAqL1xyXG4gIGlzTm90Rm91bmQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09IDQwNDtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBlcnJvciBpcyBhIDQwOSBDb25mbGljdCBlcnJvci5cclxuICAgKi9cclxuICBpc0NvbmZsaWN0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSA0MDk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZXJyb3IgaXMgYSA0MTkgQXV0aGVudGljYXRpb24gVGltZW91dCBlcnJvci5cclxuICAgKi9cclxuICBpc0F1dGhlbnRpY2F0aW9uVGltZW91dCgpIHtcclxuICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gNDE5O1xyXG4gIH1cclxufTtcclxuXHJcbi8vIHNyYy91dGlscy91cmwudHNcclxuZnVuY3Rpb24gYnVpbGRVcmwoYmFzZVVybCwgcGF0aCwgcXVlcnkpIHtcclxuICBjb25zdCB1cmwgPSBuZXcgVVJMKHBhdGgsIGJhc2VVcmwpO1xyXG4gIGlmIChxdWVyeSkge1xyXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocXVlcnkpKSB7XHJcbiAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XHJcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHVybC50b1N0cmluZygpO1xyXG59XHJcblxyXG4vLyBzcmMvaHR0cC9jcmVhdGVGZXRjaENsaWVudC50c1xyXG5hc3luYyBmdW5jdGlvbiBidWlsZEF1dGhIZWFkZXJzKGF1dGgpIHtcclxuICBpZiAoIWF1dGggfHwgYXV0aC50eXBlID09PSBcIm5vbmVcIikge1xyXG4gICAgcmV0dXJuIHt9O1xyXG4gIH1cclxuICBpZiAoYXV0aC50eXBlID09PSBcImJlYXJlclwiKSB7XHJcbiAgICByZXR1cm4geyBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YXV0aC50b2tlbn1gIH07XHJcbiAgfVxyXG4gIGlmIChhdXRoLnR5cGUgPT09IFwiaGVhZGVyXCIpIHtcclxuICAgIHJldHVybiB7IFthdXRoLm5hbWVdOiBhdXRoLnZhbHVlIH07XHJcbiAgfVxyXG4gIGlmIChhdXRoLnR5cGUgPT09IFwiY3VzdG9tXCIpIHtcclxuICAgIHJldHVybiBhd2FpdCBhdXRoLmdldEhlYWRlcnMoKTtcclxuICB9XHJcbiAgcmV0dXJuIHt9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUZldGNoQ2xpZW50KG9wdGlvbnMpIHtcclxuICBjb25zdCBmZXRjaEZuID0gb3B0aW9ucy5mZXRjaEltcGwgPz8gZ2xvYmFsVGhpcy5mZXRjaDtcclxuICByZXR1cm4ge1xyXG4gICAgYXN5bmMgcmVxdWVzdCh7XHJcbiAgICAgIG1ldGhvZCxcclxuICAgICAgcGF0aCxcclxuICAgICAgcXVlcnksXHJcbiAgICAgIGJvZHksXHJcbiAgICAgIGhlYWRlcnNcclxuICAgIH0pIHtcclxuICAgICAgY29uc3QgdXJsID0gYnVpbGRVcmwob3B0aW9ucy5iYXNlVXJsLCBwYXRoLCBxdWVyeSk7XHJcbiAgICAgIGNvbnN0IGF1dGhIZWFkZXJzID0gYXdhaXQgYnVpbGRBdXRoSGVhZGVycyhvcHRpb25zLmF1dGgpO1xyXG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaEZuKHVybCwge1xyXG4gICAgICAgIG1ldGhvZCxcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAuLi5ib2R5ID8geyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9IDoge30sXHJcbiAgICAgICAgICAuLi5hdXRoSGVhZGVycyxcclxuICAgICAgICAgIC4uLmhlYWRlcnNcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvZHk6IGJvZHkgPyBKU09OLnN0cmluZ2lmeShib2R5KSA6IHZvaWQgMFxyXG4gICAgICB9KTtcclxuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XHJcbiAgICAgIGNvbnN0IGlzSnNvbiA9IChyZXMuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikgfHwgXCJcIikuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xyXG4gICAgICBjb25zdCBkYXRhID0gaXNKc29uICYmIHRleHQgPyBKU09OLnBhcnNlKHRleHQpIDogdGV4dDtcclxuICAgICAgaWYgKCFyZXMub2spIHtcclxuICAgICAgICBjb25zdCBlcnJCb2R5ID0gaXNKc29uID8gZGF0YSA6IHZvaWQgMDtcclxuICAgICAgICBjb25zdCBlcnJvckRldGFpbCA9IGVyckJvZHk/LmVycm9yO1xyXG4gICAgICAgIHRocm93IG5ldyBJY2ViZXJnRXJyb3IoXHJcbiAgICAgICAgICBlcnJvckRldGFpbD8ubWVzc2FnZSA/PyBgUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgJHtyZXMuc3RhdHVzfWAsXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIHN0YXR1czogcmVzLnN0YXR1cyxcclxuICAgICAgICAgICAgaWNlYmVyZ1R5cGU6IGVycm9yRGV0YWlsPy50eXBlLFxyXG4gICAgICAgICAgICBpY2ViZXJnQ29kZTogZXJyb3JEZXRhaWw/LmNvZGUsXHJcbiAgICAgICAgICAgIGRldGFpbHM6IGVyckJvZHlcclxuICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB7IHN0YXR1czogcmVzLnN0YXR1cywgaGVhZGVyczogcmVzLmhlYWRlcnMsIGRhdGEgfTtcclxuICAgIH1cclxuICB9O1xyXG59XHJcblxyXG4vLyBzcmMvY2F0YWxvZy9uYW1lc3BhY2VzLnRzXHJcbmZ1bmN0aW9uIG5hbWVzcGFjZVRvUGF0aChuYW1lc3BhY2UpIHtcclxuICByZXR1cm4gbmFtZXNwYWNlLmpvaW4oXCJcdTAwMWZcIik7XHJcbn1cclxudmFyIE5hbWVzcGFjZU9wZXJhdGlvbnMgPSBjbGFzcyB7XHJcbiAgY29uc3RydWN0b3IoY2xpZW50LCBwcmVmaXggPSBcIlwiKSB7XHJcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcclxuICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xyXG4gIH1cclxuICBhc3luYyBsaXN0TmFtZXNwYWNlcyhwYXJlbnQpIHtcclxuICAgIGNvbnN0IHF1ZXJ5ID0gcGFyZW50ID8geyBwYXJlbnQ6IG5hbWVzcGFjZVRvUGF0aChwYXJlbnQubmFtZXNwYWNlKSB9IDogdm9pZCAwO1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KHtcclxuICAgICAgbWV0aG9kOiBcIkdFVFwiLFxyXG4gICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlc2AsXHJcbiAgICAgIHF1ZXJ5XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXNwb25zZS5kYXRhLm5hbWVzcGFjZXMubWFwKChucykgPT4gKHsgbmFtZXNwYWNlOiBucyB9KSk7XHJcbiAgfVxyXG4gIGFzeW5jIGNyZWF0ZU5hbWVzcGFjZShpZCwgbWV0YWRhdGEpIHtcclxuICAgIGNvbnN0IHJlcXVlc3QgPSB7XHJcbiAgICAgIG5hbWVzcGFjZTogaWQubmFtZXNwYWNlLFxyXG4gICAgICBwcm9wZXJ0aWVzOiBtZXRhZGF0YT8ucHJvcGVydGllc1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XHJcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbiAgICAgIHBhdGg6IGAke3RoaXMucHJlZml4fS9uYW1lc3BhY2VzYCxcclxuICAgICAgYm9keTogcmVxdWVzdFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICB9XHJcbiAgYXN5bmMgZHJvcE5hbWVzcGFjZShpZCkge1xyXG4gICAgYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XHJcbiAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcclxuICAgICAgcGF0aDogYCR7dGhpcy5wcmVmaXh9L25hbWVzcGFjZXMvJHtuYW1lc3BhY2VUb1BhdGgoaWQubmFtZXNwYWNlKX1gXHJcbiAgICB9KTtcclxuICB9XHJcbiAgYXN5bmMgbG9hZE5hbWVzcGFjZU1ldGFkYXRhKGlkKSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3Qoe1xyXG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXHJcbiAgICAgIHBhdGg6IGAke3RoaXMucHJlZml4fS9uYW1lc3BhY2VzLyR7bmFtZXNwYWNlVG9QYXRoKGlkLm5hbWVzcGFjZSl9YFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBwcm9wZXJ0aWVzOiByZXNwb25zZS5kYXRhLnByb3BlcnRpZXNcclxuICAgIH07XHJcbiAgfVxyXG4gIGFzeW5jIG5hbWVzcGFjZUV4aXN0cyhpZCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XHJcbiAgICAgICAgbWV0aG9kOiBcIkhFQURcIixcclxuICAgICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlcy8ke25hbWVzcGFjZVRvUGF0aChpZC5uYW1lc3BhY2UpfWBcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgSWNlYmVyZ0Vycm9yICYmIGVycm9yLnN0YXR1cyA9PT0gNDA0KSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuICBhc3luYyBjcmVhdGVOYW1lc3BhY2VJZk5vdEV4aXN0cyhpZCwgbWV0YWRhdGEpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNyZWF0ZU5hbWVzcGFjZShpZCwgbWV0YWRhdGEpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgSWNlYmVyZ0Vycm9yICYmIGVycm9yLnN0YXR1cyA9PT0gNDA5KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbi8vIHNyYy9jYXRhbG9nL3RhYmxlcy50c1xyXG5mdW5jdGlvbiBuYW1lc3BhY2VUb1BhdGgyKG5hbWVzcGFjZSkge1xyXG4gIHJldHVybiBuYW1lc3BhY2Uuam9pbihcIlx1MDAxZlwiKTtcclxufVxyXG52YXIgVGFibGVPcGVyYXRpb25zID0gY2xhc3Mge1xyXG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgcHJlZml4ID0gXCJcIiwgYWNjZXNzRGVsZWdhdGlvbikge1xyXG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XHJcbiAgICB0aGlzLnByZWZpeCA9IHByZWZpeDtcclxuICAgIHRoaXMuYWNjZXNzRGVsZWdhdGlvbiA9IGFjY2Vzc0RlbGVnYXRpb247XHJcbiAgfVxyXG4gIGFzeW5jIGxpc3RUYWJsZXMobmFtZXNwYWNlKSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3Qoe1xyXG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXHJcbiAgICAgIHBhdGg6IGAke3RoaXMucHJlZml4fS9uYW1lc3BhY2VzLyR7bmFtZXNwYWNlVG9QYXRoMihuYW1lc3BhY2UubmFtZXNwYWNlKX0vdGFibGVzYFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5pZGVudGlmaWVycztcclxuICB9XHJcbiAgYXN5bmMgY3JlYXRlVGFibGUobmFtZXNwYWNlLCByZXF1ZXN0KSB7XHJcbiAgICBjb25zdCBoZWFkZXJzID0ge307XHJcbiAgICBpZiAodGhpcy5hY2Nlc3NEZWxlZ2F0aW9uKSB7XHJcbiAgICAgIGhlYWRlcnNbXCJYLUljZWJlcmctQWNjZXNzLURlbGVnYXRpb25cIl0gPSB0aGlzLmFjY2Vzc0RlbGVnYXRpb247XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3Qoe1xyXG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxyXG4gICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlcy8ke25hbWVzcGFjZVRvUGF0aDIobmFtZXNwYWNlLm5hbWVzcGFjZSl9L3RhYmxlc2AsXHJcbiAgICAgIGJvZHk6IHJlcXVlc3QsXHJcbiAgICAgIGhlYWRlcnNcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEubWV0YWRhdGE7XHJcbiAgfVxyXG4gIGFzeW5jIHVwZGF0ZVRhYmxlKGlkLCByZXF1ZXN0KSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3Qoe1xyXG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxyXG4gICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlcy8ke25hbWVzcGFjZVRvUGF0aDIoaWQubmFtZXNwYWNlKX0vdGFibGVzLyR7aWQubmFtZX1gLFxyXG4gICAgICBib2R5OiByZXF1ZXN0XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIFwibWV0YWRhdGEtbG9jYXRpb25cIjogcmVzcG9uc2UuZGF0YVtcIm1ldGFkYXRhLWxvY2F0aW9uXCJdLFxyXG4gICAgICBtZXRhZGF0YTogcmVzcG9uc2UuZGF0YS5tZXRhZGF0YVxyXG4gICAgfTtcclxuICB9XHJcbiAgYXN5bmMgZHJvcFRhYmxlKGlkLCBvcHRpb25zKSB7XHJcbiAgICBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KHtcclxuICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxyXG4gICAgICBwYXRoOiBgJHt0aGlzLnByZWZpeH0vbmFtZXNwYWNlcy8ke25hbWVzcGFjZVRvUGF0aDIoaWQubmFtZXNwYWNlKX0vdGFibGVzLyR7aWQubmFtZX1gLFxyXG4gICAgICBxdWVyeTogeyBwdXJnZVJlcXVlc3RlZDogU3RyaW5nKG9wdGlvbnM/LnB1cmdlID8/IGZhbHNlKSB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgYXN5bmMgbG9hZFRhYmxlKGlkKSB7XHJcbiAgICBjb25zdCBoZWFkZXJzID0ge307XHJcbiAgICBpZiAodGhpcy5hY2Nlc3NEZWxlZ2F0aW9uKSB7XHJcbiAgICAgIGhlYWRlcnNbXCJYLUljZWJlcmctQWNjZXNzLURlbGVnYXRpb25cIl0gPSB0aGlzLmFjY2Vzc0RlbGVnYXRpb247XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3Qoe1xyXG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXHJcbiAgICAgIHBhdGg6IGAke3RoaXMucHJlZml4fS9uYW1lc3BhY2VzLyR7bmFtZXNwYWNlVG9QYXRoMihpZC5uYW1lc3BhY2UpfS90YWJsZXMvJHtpZC5uYW1lfWAsXHJcbiAgICAgIGhlYWRlcnNcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEubWV0YWRhdGE7XHJcbiAgfVxyXG4gIGFzeW5jIHRhYmxlRXhpc3RzKGlkKSB7XHJcbiAgICBjb25zdCBoZWFkZXJzID0ge307XHJcbiAgICBpZiAodGhpcy5hY2Nlc3NEZWxlZ2F0aW9uKSB7XHJcbiAgICAgIGhlYWRlcnNbXCJYLUljZWJlcmctQWNjZXNzLURlbGVnYXRpb25cIl0gPSB0aGlzLmFjY2Vzc0RlbGVnYXRpb247XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICBhd2FpdCB0aGlzLmNsaWVudC5yZXF1ZXN0KHtcclxuICAgICAgICBtZXRob2Q6IFwiSEVBRFwiLFxyXG4gICAgICAgIHBhdGg6IGAke3RoaXMucHJlZml4fS9uYW1lc3BhY2VzLyR7bmFtZXNwYWNlVG9QYXRoMihpZC5uYW1lc3BhY2UpfS90YWJsZXMvJHtpZC5uYW1lfWAsXHJcbiAgICAgICAgaGVhZGVyc1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBJY2ViZXJnRXJyb3IgJiYgZXJyb3Iuc3RhdHVzID09PSA0MDQpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGFzeW5jIGNyZWF0ZVRhYmxlSWZOb3RFeGlzdHMobmFtZXNwYWNlLCByZXF1ZXN0KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5jcmVhdGVUYWJsZShuYW1lc3BhY2UsIHJlcXVlc3QpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgSWNlYmVyZ0Vycm9yICYmIGVycm9yLnN0YXR1cyA9PT0gNDA5KSB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubG9hZFRhYmxlKHsgbmFtZXNwYWNlOiBuYW1lc3BhY2UubmFtZXNwYWNlLCBuYW1lOiByZXF1ZXN0Lm5hbWUgfSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gc3JjL2NhdGFsb2cvSWNlYmVyZ1Jlc3RDYXRhbG9nLnRzXHJcbnZhciBJY2ViZXJnUmVzdENhdGFsb2cgPSBjbGFzcyB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG5ldyBJY2ViZXJnIFJFU1QgQ2F0YWxvZyBjbGllbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIGNhdGFsb2cgY2xpZW50XHJcbiAgICovXHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgbGV0IHByZWZpeCA9IFwidjFcIjtcclxuICAgIGlmIChvcHRpb25zLmNhdGFsb2dOYW1lKSB7XHJcbiAgICAgIHByZWZpeCArPSBgLyR7b3B0aW9ucy5jYXRhbG9nTmFtZX1gO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYmFzZVVybCA9IG9wdGlvbnMuYmFzZVVybC5lbmRzV2l0aChcIi9cIikgPyBvcHRpb25zLmJhc2VVcmwgOiBgJHtvcHRpb25zLmJhc2VVcmx9L2A7XHJcbiAgICB0aGlzLmNsaWVudCA9IGNyZWF0ZUZldGNoQ2xpZW50KHtcclxuICAgICAgYmFzZVVybCxcclxuICAgICAgYXV0aDogb3B0aW9ucy5hdXRoLFxyXG4gICAgICBmZXRjaEltcGw6IG9wdGlvbnMuZmV0Y2hcclxuICAgIH0pO1xyXG4gICAgdGhpcy5hY2Nlc3NEZWxlZ2F0aW9uID0gb3B0aW9ucy5hY2Nlc3NEZWxlZ2F0aW9uPy5qb2luKFwiLFwiKTtcclxuICAgIHRoaXMubmFtZXNwYWNlT3BzID0gbmV3IE5hbWVzcGFjZU9wZXJhdGlvbnModGhpcy5jbGllbnQsIHByZWZpeCk7XHJcbiAgICB0aGlzLnRhYmxlT3BzID0gbmV3IFRhYmxlT3BlcmF0aW9ucyh0aGlzLmNsaWVudCwgcHJlZml4LCB0aGlzLmFjY2Vzc0RlbGVnYXRpb24pO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBMaXN0cyBhbGwgbmFtZXNwYWNlcyBpbiB0aGUgY2F0YWxvZy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBwYXJlbnQgLSBPcHRpb25hbCBwYXJlbnQgbmFtZXNwYWNlIHRvIGxpc3QgY2hpbGRyZW4gdW5kZXJcclxuICAgKiBAcmV0dXJucyBBcnJheSBvZiBuYW1lc3BhY2UgaWRlbnRpZmllcnNcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAqIC8vIExpc3QgYWxsIHRvcC1sZXZlbCBuYW1lc3BhY2VzXHJcbiAgICogY29uc3QgbmFtZXNwYWNlcyA9IGF3YWl0IGNhdGFsb2cubGlzdE5hbWVzcGFjZXMoKTtcclxuICAgKlxyXG4gICAqIC8vIExpc3QgbmFtZXNwYWNlcyB1bmRlciBhIHBhcmVudFxyXG4gICAqIGNvbnN0IGNoaWxkcmVuID0gYXdhaXQgY2F0YWxvZy5saXN0TmFtZXNwYWNlcyh7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSB9KTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuICBhc3luYyBsaXN0TmFtZXNwYWNlcyhwYXJlbnQpIHtcclxuICAgIHJldHVybiB0aGlzLm5hbWVzcGFjZU9wcy5saXN0TmFtZXNwYWNlcyhwYXJlbnQpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmV3IG5hbWVzcGFjZSBpbiB0aGUgY2F0YWxvZy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBpZCAtIE5hbWVzcGFjZSBpZGVudGlmaWVyIHRvIGNyZWF0ZVxyXG4gICAqIEBwYXJhbSBtZXRhZGF0YSAtIE9wdGlvbmFsIG1ldGFkYXRhIHByb3BlcnRpZXMgZm9yIHRoZSBuYW1lc3BhY2VcclxuICAgKiBAcmV0dXJucyBSZXNwb25zZSBjb250YWluaW5nIHRoZSBjcmVhdGVkIG5hbWVzcGFjZSBhbmQgaXRzIHByb3BlcnRpZXNcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2F0YWxvZy5jcmVhdGVOYW1lc3BhY2UoXHJcbiAgICogICB7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSB9LFxyXG4gICAqICAgeyBwcm9wZXJ0aWVzOiB7IG93bmVyOiAnZGF0YS10ZWFtJyB9IH1cclxuICAgKiApO1xyXG4gICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlLm5hbWVzcGFjZSk7IC8vIFsnYW5hbHl0aWNzJ11cclxuICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZS5wcm9wZXJ0aWVzKTsgLy8geyBvd25lcjogJ2RhdGEtdGVhbScsIC4uLiB9XHJcbiAgICogYGBgXHJcbiAgICovXHJcbiAgYXN5bmMgY3JlYXRlTmFtZXNwYWNlKGlkLCBtZXRhZGF0YSkge1xyXG4gICAgcmV0dXJuIHRoaXMubmFtZXNwYWNlT3BzLmNyZWF0ZU5hbWVzcGFjZShpZCwgbWV0YWRhdGEpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBEcm9wcyBhIG5hbWVzcGFjZSBmcm9tIHRoZSBjYXRhbG9nLlxyXG4gICAqXHJcbiAgICogVGhlIG5hbWVzcGFjZSBtdXN0IGJlIGVtcHR5IChjb250YWluIG5vIHRhYmxlcykgYmVmb3JlIGl0IGNhbiBiZSBkcm9wcGVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGlkIC0gTmFtZXNwYWNlIGlkZW50aWZpZXIgdG8gZHJvcFxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICogYXdhaXQgY2F0YWxvZy5kcm9wTmFtZXNwYWNlKHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddIH0pO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG4gIGFzeW5jIGRyb3BOYW1lc3BhY2UoaWQpIHtcclxuICAgIGF3YWl0IHRoaXMubmFtZXNwYWNlT3BzLmRyb3BOYW1lc3BhY2UoaWQpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBMb2FkcyBtZXRhZGF0YSBmb3IgYSBuYW1lc3BhY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gaWQgLSBOYW1lc3BhY2UgaWRlbnRpZmllciB0byBsb2FkXHJcbiAgICogQHJldHVybnMgTmFtZXNwYWNlIG1ldGFkYXRhIGluY2x1ZGluZyBwcm9wZXJ0aWVzXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYHR5cGVzY3JpcHRcclxuICAgKiBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IGNhdGFsb2cubG9hZE5hbWVzcGFjZU1ldGFkYXRhKHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddIH0pO1xyXG4gICAqIGNvbnNvbGUubG9nKG1ldGFkYXRhLnByb3BlcnRpZXMpO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG4gIGFzeW5jIGxvYWROYW1lc3BhY2VNZXRhZGF0YShpZCkge1xyXG4gICAgcmV0dXJuIHRoaXMubmFtZXNwYWNlT3BzLmxvYWROYW1lc3BhY2VNZXRhZGF0YShpZCk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIExpc3RzIGFsbCB0YWJsZXMgaW4gYSBuYW1lc3BhY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gbmFtZXNwYWNlIC0gTmFtZXNwYWNlIGlkZW50aWZpZXIgdG8gbGlzdCB0YWJsZXMgZnJvbVxyXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIHRhYmxlIGlkZW50aWZpZXJzXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYHR5cGVzY3JpcHRcclxuICAgKiBjb25zdCB0YWJsZXMgPSBhd2FpdCBjYXRhbG9nLmxpc3RUYWJsZXMoeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10gfSk7XHJcbiAgICogY29uc29sZS5sb2codGFibGVzKTsgLy8gW3sgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddLCBuYW1lOiAnZXZlbnRzJyB9LCAuLi5dXHJcbiAgICogYGBgXHJcbiAgICovXHJcbiAgYXN5bmMgbGlzdFRhYmxlcyhuYW1lc3BhY2UpIHtcclxuICAgIHJldHVybiB0aGlzLnRhYmxlT3BzLmxpc3RUYWJsZXMobmFtZXNwYWNlKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG5ldyB0YWJsZSBpbiB0aGUgY2F0YWxvZy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBuYW1lc3BhY2UgLSBOYW1lc3BhY2UgdG8gY3JlYXRlIHRoZSB0YWJsZSBpblxyXG4gICAqIEBwYXJhbSByZXF1ZXN0IC0gVGFibGUgY3JlYXRpb24gcmVxdWVzdCBpbmNsdWRpbmcgbmFtZSwgc2NoZW1hLCBwYXJ0aXRpb24gc3BlYywgZXRjLlxyXG4gICAqIEByZXR1cm5zIFRhYmxlIG1ldGFkYXRhIGZvciB0aGUgY3JlYXRlZCB0YWJsZVxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICogY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBjYXRhbG9nLmNyZWF0ZVRhYmxlKFxyXG4gICAqICAgeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10gfSxcclxuICAgKiAgIHtcclxuICAgKiAgICAgbmFtZTogJ2V2ZW50cycsXHJcbiAgICogICAgIHNjaGVtYToge1xyXG4gICAqICAgICAgIHR5cGU6ICdzdHJ1Y3QnLFxyXG4gICAqICAgICAgIGZpZWxkczogW1xyXG4gICAqICAgICAgICAgeyBpZDogMSwgbmFtZTogJ2lkJywgdHlwZTogJ2xvbmcnLCByZXF1aXJlZDogdHJ1ZSB9LFxyXG4gICAqICAgICAgICAgeyBpZDogMiwgbmFtZTogJ3RpbWVzdGFtcCcsIHR5cGU6ICd0aW1lc3RhbXAnLCByZXF1aXJlZDogdHJ1ZSB9XHJcbiAgICogICAgICAgXSxcclxuICAgKiAgICAgICAnc2NoZW1hLWlkJzogMFxyXG4gICAqICAgICB9LFxyXG4gICAqICAgICAncGFydGl0aW9uLXNwZWMnOiB7XHJcbiAgICogICAgICAgJ3NwZWMtaWQnOiAwLFxyXG4gICAqICAgICAgIGZpZWxkczogW1xyXG4gICAqICAgICAgICAgeyBzb3VyY2VfaWQ6IDIsIGZpZWxkX2lkOiAxMDAwLCBuYW1lOiAndHNfZGF5JywgdHJhbnNmb3JtOiAnZGF5JyB9XHJcbiAgICogICAgICAgXVxyXG4gICAqICAgICB9XHJcbiAgICogICB9XHJcbiAgICogKTtcclxuICAgKiBgYGBcclxuICAgKi9cclxuICBhc3luYyBjcmVhdGVUYWJsZShuYW1lc3BhY2UsIHJlcXVlc3QpIHtcclxuICAgIHJldHVybiB0aGlzLnRhYmxlT3BzLmNyZWF0ZVRhYmxlKG5hbWVzcGFjZSwgcmVxdWVzdCk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgYW4gZXhpc3RpbmcgdGFibGUncyBtZXRhZGF0YS5cclxuICAgKlxyXG4gICAqIENhbiB1cGRhdGUgdGhlIHNjaGVtYSwgcGFydGl0aW9uIHNwZWMsIG9yIHByb3BlcnRpZXMgb2YgYSB0YWJsZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBpZCAtIFRhYmxlIGlkZW50aWZpZXIgdG8gdXBkYXRlXHJcbiAgICogQHBhcmFtIHJlcXVlc3QgLSBVcGRhdGUgcmVxdWVzdCB3aXRoIGZpZWxkcyB0byBtb2RpZnlcclxuICAgKiBAcmV0dXJucyBSZXNwb25zZSBjb250YWluaW5nIHRoZSBtZXRhZGF0YSBsb2NhdGlvbiBhbmQgdXBkYXRlZCB0YWJsZSBtZXRhZGF0YVxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjYXRhbG9nLnVwZGF0ZVRhYmxlKFxyXG4gICAqICAgeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10sIG5hbWU6ICdldmVudHMnIH0sXHJcbiAgICogICB7XHJcbiAgICogICAgIHByb3BlcnRpZXM6IHsgJ3JlYWQuc3BsaXQudGFyZ2V0LXNpemUnOiAnMTM0MjE3NzI4JyB9XHJcbiAgICogICB9XHJcbiAgICogKTtcclxuICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZVsnbWV0YWRhdGEtbG9jYXRpb24nXSk7IC8vIHMzOi8vLi4uXHJcbiAgICogY29uc29sZS5sb2cocmVzcG9uc2UubWV0YWRhdGEpOyAvLyBUYWJsZU1ldGFkYXRhIG9iamVjdFxyXG4gICAqIGBgYFxyXG4gICAqL1xyXG4gIGFzeW5jIHVwZGF0ZVRhYmxlKGlkLCByZXF1ZXN0KSB7XHJcbiAgICByZXR1cm4gdGhpcy50YWJsZU9wcy51cGRhdGVUYWJsZShpZCwgcmVxdWVzdCk7XHJcbiAgfVxyXG4gIC8qKlxyXG4gICAqIERyb3BzIGEgdGFibGUgZnJvbSB0aGUgY2F0YWxvZy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBpZCAtIFRhYmxlIGlkZW50aWZpZXIgdG8gZHJvcFxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICogYXdhaXQgY2F0YWxvZy5kcm9wVGFibGUoeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10sIG5hbWU6ICdldmVudHMnIH0pO1xyXG4gICAqIGBgYFxyXG4gICAqL1xyXG4gIGFzeW5jIGRyb3BUYWJsZShpZCwgb3B0aW9ucykge1xyXG4gICAgYXdhaXQgdGhpcy50YWJsZU9wcy5kcm9wVGFibGUoaWQsIG9wdGlvbnMpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBMb2FkcyBtZXRhZGF0YSBmb3IgYSB0YWJsZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBpZCAtIFRhYmxlIGlkZW50aWZpZXIgdG8gbG9hZFxyXG4gICAqIEByZXR1cm5zIFRhYmxlIG1ldGFkYXRhIGluY2x1ZGluZyBzY2hlbWEsIHBhcnRpdGlvbiBzcGVjLCBsb2NhdGlvbiwgZXRjLlxyXG4gICAqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICogY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBjYXRhbG9nLmxvYWRUYWJsZSh7IG5hbWVzcGFjZTogWydhbmFseXRpY3MnXSwgbmFtZTogJ2V2ZW50cycgfSk7XHJcbiAgICogY29uc29sZS5sb2cobWV0YWRhdGEuc2NoZW1hKTtcclxuICAgKiBjb25zb2xlLmxvZyhtZXRhZGF0YS5sb2NhdGlvbik7XHJcbiAgICogYGBgXHJcbiAgICovXHJcbiAgYXN5bmMgbG9hZFRhYmxlKGlkKSB7XHJcbiAgICByZXR1cm4gdGhpcy50YWJsZU9wcy5sb2FkVGFibGUoaWQpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBDaGVja3MgaWYgYSBuYW1lc3BhY2UgZXhpc3RzIGluIHRoZSBjYXRhbG9nLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGlkIC0gTmFtZXNwYWNlIGlkZW50aWZpZXIgdG8gY2hlY2tcclxuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBuYW1lc3BhY2UgZXhpc3RzLCBmYWxzZSBvdGhlcndpc2VcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAqIGNvbnN0IGV4aXN0cyA9IGF3YWl0IGNhdGFsb2cubmFtZXNwYWNlRXhpc3RzKHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddIH0pO1xyXG4gICAqIGNvbnNvbGUubG9nKGV4aXN0cyk7IC8vIHRydWUgb3IgZmFsc2VcclxuICAgKiBgYGBcclxuICAgKi9cclxuICBhc3luYyBuYW1lc3BhY2VFeGlzdHMoaWQpIHtcclxuICAgIHJldHVybiB0aGlzLm5hbWVzcGFjZU9wcy5uYW1lc3BhY2VFeGlzdHMoaWQpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBDaGVja3MgaWYgYSB0YWJsZSBleGlzdHMgaW4gdGhlIGNhdGFsb2cuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gaWQgLSBUYWJsZSBpZGVudGlmaWVyIHRvIGNoZWNrXHJcbiAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdGFibGUgZXhpc3RzLCBmYWxzZSBvdGhlcndpc2VcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAqIGNvbnN0IGV4aXN0cyA9IGF3YWl0IGNhdGFsb2cudGFibGVFeGlzdHMoeyBuYW1lc3BhY2U6IFsnYW5hbHl0aWNzJ10sIG5hbWU6ICdldmVudHMnIH0pO1xyXG4gICAqIGNvbnNvbGUubG9nKGV4aXN0cyk7IC8vIHRydWUgb3IgZmFsc2VcclxuICAgKiBgYGBcclxuICAgKi9cclxuICBhc3luYyB0YWJsZUV4aXN0cyhpZCkge1xyXG4gICAgcmV0dXJuIHRoaXMudGFibGVPcHMudGFibGVFeGlzdHMoaWQpO1xyXG4gIH1cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgbmFtZXNwYWNlIGlmIGl0IGRvZXMgbm90IGV4aXN0LlxyXG4gICAqXHJcbiAgICogSWYgdGhlIG5hbWVzcGFjZSBhbHJlYWR5IGV4aXN0cywgcmV0dXJucyB2b2lkLiBJZiBjcmVhdGVkLCByZXR1cm5zIHRoZSByZXNwb25zZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBpZCAtIE5hbWVzcGFjZSBpZGVudGlmaWVyIHRvIGNyZWF0ZVxyXG4gICAqIEBwYXJhbSBtZXRhZGF0YSAtIE9wdGlvbmFsIG1ldGFkYXRhIHByb3BlcnRpZXMgZm9yIHRoZSBuYW1lc3BhY2VcclxuICAgKiBAcmV0dXJucyBSZXNwb25zZSBjb250YWluaW5nIHRoZSBjcmVhdGVkIG5hbWVzcGFjZSBhbmQgaXRzIHByb3BlcnRpZXMsIG9yIHZvaWQgaWYgaXQgYWxyZWFkeSBleGlzdHNcclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2F0YWxvZy5jcmVhdGVOYW1lc3BhY2VJZk5vdEV4aXN0cyhcclxuICAgKiAgIHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddIH0sXHJcbiAgICogICB7IHByb3BlcnRpZXM6IHsgb3duZXI6ICdkYXRhLXRlYW0nIH0gfVxyXG4gICAqICk7XHJcbiAgICogaWYgKHJlc3BvbnNlKSB7XHJcbiAgICogICBjb25zb2xlLmxvZygnQ3JlYXRlZDonLCByZXNwb25zZS5uYW1lc3BhY2UpO1xyXG4gICAqIH0gZWxzZSB7XHJcbiAgICogICBjb25zb2xlLmxvZygnQWxyZWFkeSBleGlzdHMnKTtcclxuICAgKiB9XHJcbiAgICogYGBgXHJcbiAgICovXHJcbiAgYXN5bmMgY3JlYXRlTmFtZXNwYWNlSWZOb3RFeGlzdHMoaWQsIG1ldGFkYXRhKSB7XHJcbiAgICByZXR1cm4gdGhpcy5uYW1lc3BhY2VPcHMuY3JlYXRlTmFtZXNwYWNlSWZOb3RFeGlzdHMoaWQsIG1ldGFkYXRhKTtcclxuICB9XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIHRhYmxlIGlmIGl0IGRvZXMgbm90IGV4aXN0LlxyXG4gICAqXHJcbiAgICogSWYgdGhlIHRhYmxlIGFscmVhZHkgZXhpc3RzLCByZXR1cm5zIGl0cyBtZXRhZGF0YSBpbnN0ZWFkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG5hbWVzcGFjZSAtIE5hbWVzcGFjZSB0byBjcmVhdGUgdGhlIHRhYmxlIGluXHJcbiAgICogQHBhcmFtIHJlcXVlc3QgLSBUYWJsZSBjcmVhdGlvbiByZXF1ZXN0IGluY2x1ZGluZyBuYW1lLCBzY2hlbWEsIHBhcnRpdGlvbiBzcGVjLCBldGMuXHJcbiAgICogQHJldHVybnMgVGFibGUgbWV0YWRhdGEgZm9yIHRoZSBjcmVhdGVkIG9yIGV4aXN0aW5nIHRhYmxlXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIGBgYHR5cGVzY3JpcHRcclxuICAgKiBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IGNhdGFsb2cuY3JlYXRlVGFibGVJZk5vdEV4aXN0cyhcclxuICAgKiAgIHsgbmFtZXNwYWNlOiBbJ2FuYWx5dGljcyddIH0sXHJcbiAgICogICB7XHJcbiAgICogICAgIG5hbWU6ICdldmVudHMnLFxyXG4gICAqICAgICBzY2hlbWE6IHtcclxuICAgKiAgICAgICB0eXBlOiAnc3RydWN0JyxcclxuICAgKiAgICAgICBmaWVsZHM6IFtcclxuICAgKiAgICAgICAgIHsgaWQ6IDEsIG5hbWU6ICdpZCcsIHR5cGU6ICdsb25nJywgcmVxdWlyZWQ6IHRydWUgfSxcclxuICAgKiAgICAgICAgIHsgaWQ6IDIsIG5hbWU6ICd0aW1lc3RhbXAnLCB0eXBlOiAndGltZXN0YW1wJywgcmVxdWlyZWQ6IHRydWUgfVxyXG4gICAqICAgICAgIF0sXHJcbiAgICogICAgICAgJ3NjaGVtYS1pZCc6IDBcclxuICAgKiAgICAgfVxyXG4gICAqICAgfVxyXG4gICAqICk7XHJcbiAgICogYGBgXHJcbiAgICovXHJcbiAgYXN5bmMgY3JlYXRlVGFibGVJZk5vdEV4aXN0cyhuYW1lc3BhY2UsIHJlcXVlc3QpIHtcclxuICAgIHJldHVybiB0aGlzLnRhYmxlT3BzLmNyZWF0ZVRhYmxlSWZOb3RFeGlzdHMobmFtZXNwYWNlLCByZXF1ZXN0KTtcclxuICB9XHJcbn07XHJcblxyXG4vLyBzcmMvY2F0YWxvZy90eXBlcy50c1xyXG52YXIgREVDSU1BTF9SRUdFWCA9IC9eZGVjaW1hbFxccypcXChcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKlxcKSQvO1xyXG52YXIgRklYRURfUkVHRVggPSAvXmZpeGVkXFxzKlxcW1xccyooXFxkKylcXHMqXFxdJC87XHJcbmZ1bmN0aW9uIHBhcnNlRGVjaW1hbFR5cGUodHlwZSkge1xyXG4gIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaChERUNJTUFMX1JFR0VYKTtcclxuICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcclxuICByZXR1cm4ge1xyXG4gICAgcHJlY2lzaW9uOiBwYXJzZUludChtYXRjaFsxXSwgMTApLFxyXG4gICAgc2NhbGU6IHBhcnNlSW50KG1hdGNoWzJdLCAxMClcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlRml4ZWRUeXBlKHR5cGUpIHtcclxuICBjb25zdCBtYXRjaCA9IHR5cGUubWF0Y2goRklYRURfUkVHRVgpO1xyXG4gIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xyXG4gIHJldHVybiB7XHJcbiAgICBsZW5ndGg6IHBhcnNlSW50KG1hdGNoWzFdLCAxMClcclxuICB9O1xyXG59XHJcbmZ1bmN0aW9uIGlzRGVjaW1hbFR5cGUodHlwZSkge1xyXG4gIHJldHVybiBERUNJTUFMX1JFR0VYLnRlc3QodHlwZSk7XHJcbn1cclxuZnVuY3Rpb24gaXNGaXhlZFR5cGUodHlwZSkge1xyXG4gIHJldHVybiBGSVhFRF9SRUdFWC50ZXN0KHR5cGUpO1xyXG59XHJcbmZ1bmN0aW9uIHR5cGVzRXF1YWwoYSwgYikge1xyXG4gIGNvbnN0IGRlY2ltYWxBID0gcGFyc2VEZWNpbWFsVHlwZShhKTtcclxuICBjb25zdCBkZWNpbWFsQiA9IHBhcnNlRGVjaW1hbFR5cGUoYik7XHJcbiAgaWYgKGRlY2ltYWxBICYmIGRlY2ltYWxCKSB7XHJcbiAgICByZXR1cm4gZGVjaW1hbEEucHJlY2lzaW9uID09PSBkZWNpbWFsQi5wcmVjaXNpb24gJiYgZGVjaW1hbEEuc2NhbGUgPT09IGRlY2ltYWxCLnNjYWxlO1xyXG4gIH1cclxuICBjb25zdCBmaXhlZEEgPSBwYXJzZUZpeGVkVHlwZShhKTtcclxuICBjb25zdCBmaXhlZEIgPSBwYXJzZUZpeGVkVHlwZShiKTtcclxuICBpZiAoZml4ZWRBICYmIGZpeGVkQikge1xyXG4gICAgcmV0dXJuIGZpeGVkQS5sZW5ndGggPT09IGZpeGVkQi5sZW5ndGg7XHJcbiAgfVxyXG4gIHJldHVybiBhID09PSBiO1xyXG59XHJcbmZ1bmN0aW9uIGdldEN1cnJlbnRTY2hlbWEobWV0YWRhdGEpIHtcclxuICByZXR1cm4gbWV0YWRhdGEuc2NoZW1hcy5maW5kKChzKSA9PiBzW1wic2NoZW1hLWlkXCJdID09PSBtZXRhZGF0YVtcImN1cnJlbnQtc2NoZW1hLWlkXCJdKTtcclxufVxyXG5cclxuZXhwb3J0IHsgSWNlYmVyZ0Vycm9yLCBJY2ViZXJnUmVzdENhdGFsb2csIGdldEN1cnJlbnRTY2hlbWEsIGlzRGVjaW1hbFR5cGUsIGlzRml4ZWRUeXBlLCBwYXJzZURlY2ltYWxUeXBlLCBwYXJzZUZpeGVkVHlwZSwgdHlwZXNFcXVhbCB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/iceberg-js/dist/index.mjs\n");

/***/ })

};
;